using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Telegram.Bot.Types;
using TelegramSearchBot.Domain.Message;
using TelegramSearchBot.Test.Configuration;
using TelegramSearchBot.Test.Helpers;
using TelegramSearchBot.Test.Integration;
using Xunit;
using Xunit.Abstractions;

namespace TelegramSearchBot.Test.Integration
{
    /// <summary>
    /// æ¶ˆæ¯å¤„ç†æµç¨‹é›†æˆæµ‹è¯•
    /// </summary>
    public class MessageProcessingIntegrationTests : IntegrationTestBase
    {
        public MessageProcessingIntegrationTests(ITestOutputHelper output) : base(output)
        {
        }

        [Fact]
        public async Task ProcessTextMessage_ShouldStoreAndProcessCorrectly()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var testMessage = TestDataFactory.CreateTextMessage(text: "è¿™æ˜¯ä¸€æ¡æµ‹è¯•æ–‡æœ¬æ¶ˆæ¯");
                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(testMessage);
                var processingTime = StopPerformanceMonitoring("TextMessageProcessing");

                // Assert
                await AssertMessageExistsAsync(testMessage.MessageId);
                await AssertMessageProcessedAsync(testMessage.MessageId);

                // éªŒè¯æ¶ˆæ¯å†…å®¹æ­£ç¡®å­˜å‚¨
                var repository = GetMessageRepository();
                var storedMessage = await repository.GetByIdAsync(testMessage.MessageId);
                Assert.NotNull(storedMessage);
                Assert.Equal("è¿™æ˜¯ä¸€æ¡æµ‹è¯•æ–‡æœ¬æ¶ˆæ¯", storedMessage.Text);
                Assert.Equal(testMessage.ChatId, storedMessage.ChatId);
                Assert.Equal(testMessage.UserId, storedMessage.UserId);

                // éªŒè¯æ€§èƒ½
                Assert.True(processingTime < 1000, $"æ–‡æœ¬æ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 1000ms");

                LogTestInfo($"æ–‡æœ¬æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}ms");
            });
        }

        [Fact]
        public async Task ProcessPhotoMessage_ShouldTriggerOCRAndStoreCorrectly()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var testMessage = TestDataFactory.CreatePhotoMessage(text: "è¿™æ˜¯ä¸€æ¡å›¾ç‰‡æ¶ˆæ¯");
                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(testMessage);
                var processingTime = StopPerformanceMonitoring("PhotoMessageProcessing");

                // Assert
                await AssertMessageExistsAsync(testMessage.MessageId);
                await AssertMessageProcessedAsync(testMessage.MessageId);

                // éªŒè¯OCRæ‰©å±•è¢«åˆ›å»º
                await AssertMessageExtensionExistsAsync(testMessage.MessageId, "ocr");

                // éªŒè¯OCRå†…å®¹
                using var context = GetDbContext();
                var ocrExtension = await context.MessageExtensions
                    .FirstOrDefaultAsync(e => e.MessageId == testMessage.MessageId && e.ExtensionType == "ocr");
                
                Assert.NotNull(ocrExtension);
                Assert.Contains("å›¾ç‰‡ä¸­çš„æ–‡å­—å†…å®¹", ocrExtension.ExtensionData);

                // éªŒè¯æ€§èƒ½
                Assert.True(processingTime < 2000, $"å›¾ç‰‡æ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 2000ms");

                LogTestInfo($"å›¾ç‰‡æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}ms");
            });
        }

        [Fact]
        public async Task ProcessVoiceMessage_ShouldTriggerASRAndStoreCorrectly()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var testMessage = TestDataFactory.CreateVoiceMessage();
                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(testMessage);
                var processingTime = StopPerformanceMonitoring("VoiceMessageProcessing");

                // Assert
                await AssertMessageExistsAsync(testMessage.MessageId);
                await AssertMessageProcessedAsync(testMessage.MessageId);

                // éªŒè¯ASRæ‰©å±•è¢«åˆ›å»º
                await AssertMessageExtensionExistsAsync(testMessage.MessageId, "asr");

                // éªŒè¯ASRå†…å®¹
                using var context = GetDbContext();
                var asrExtension = await context.MessageExtensions
                    .FirstOrDefaultAsync(e => e.MessageId == testMessage.MessageId && e.ExtensionType == "asr");
                
                Assert.NotNull(asrExtension);
                Assert.Contains("è¯­éŸ³è½¬å†™çš„æ–‡å­—", asrExtension.ExtensionData);

                // éªŒè¯æ€§èƒ½
                Assert.True(processingTime < 3000, $"è¯­éŸ³æ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 3000ms");

                LogTestInfo($"è¯­éŸ³æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}ms");
            });
        }

        [Fact]
        public async Task ProcessMultimediaMessage_ShouldHandleMultipleContentTypes()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var testMessage = TestDataFactory.CreateMultimediaMessage(text: "è¿™æ˜¯ä¸€æ¡å¤šåª’ä½“æ¶ˆæ¯ï¼ŒåŒ…å«æ–‡å­—å’Œå›¾ç‰‡");
                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(testMessage);
                var processingTime = StopPerformanceMonitoring("MultimediaMessageProcessing");

                // Assert
                await AssertMessageExistsAsync(testMessage.MessageId);
                await AssertMessageProcessedAsync(testMessage.MessageId);

                // éªŒè¯æ¶ˆæ¯åŒ…å«æ–‡æœ¬å†…å®¹
                var repository = GetMessageRepository();
                var storedMessage = await repository.GetByIdAsync(testMessage.MessageId);
                Assert.NotNull(storedMessage);
                Assert.Contains("å¤šåª’ä½“æ¶ˆæ¯", storedMessage.Text);

                // éªŒè¯OCRæ‰©å±•è¢«åˆ›å»ºï¼ˆå› ä¸ºæœ‰å›¾ç‰‡ï¼‰
                await AssertMessageExtensionExistsAsync(testMessage.MessageId, "ocr");

                // éªŒè¯å‘é‡æ‰©å±•è¢«åˆ›å»º
                await AssertMessageExtensionExistsAsync(testMessage.MessageId, "vector");

                // éªŒè¯æ€§èƒ½
                Assert.True(processingTime < 2500, $"å¤šåª’ä½“æ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 2500ms");

                LogTestInfo($"å¤šåª’ä½“æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}ms");
            });
        }

        [Fact]
        public async Task ProcessMultipleMessages_ShouldHandleConcurrentProcessing()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var testMessages = TestDataFactory.CreateMessageList(10, MessageType.Text);
                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                
                // å¹¶è¡Œå¤„ç†å¤šä¸ªæ¶ˆæ¯
                var processingTasks = testMessages.Select(async message =>
                {
                    await processingPipeline.ProcessMessageAsync(message);
                });
                
                await Task.WhenAll(processingTasks);
                var totalProcessingTime = StopPerformanceMonitoring("ConcurrentMessageProcessing");

                // Assert
                foreach (var message in testMessages)
                {
                    await AssertMessageExistsAsync(message.MessageId);
                    await AssertMessageProcessedAsync(message.MessageId);
                }

                // éªŒè¯æ‰€æœ‰æ¶ˆæ¯éƒ½è¢«æ­£ç¡®å­˜å‚¨
                var repository = GetMessageRepository();
                var allMessages = await repository.GetAllAsync();
                Assert.Equal(testMessages.Count, allMessages.Count());

                // éªŒè¯æ€§èƒ½
                var averageTimePerMessage = totalProcessingTime / testMessages.Count;
                Assert.True(averageTimePerMessage < 500, $"å¹³å‡æ¯æ¡æ¶ˆæ¯å¤„ç†æ—¶é—´ {averageTimePerMessage}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 500ms");

                LogTestInfo($"å¹¶å‘æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œæ€»å¤„ç†æ—¶é—´: {totalProcessingTime}msï¼Œå¹³å‡æ¯æ¡: {averageTimePerMessage}ms");
            });
        }

        [Fact]
        public async Task ProcessEditedMessage_ShouldUpdateContentCorrectly()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var originalMessage = TestDataFactory.CreateTextMessage(text: "åŸå§‹æ¶ˆæ¯å†…å®¹");
                var editedMessage = TestDataFactory.CreateEditedMessage(
                    originalText: "åŸå§‹æ¶ˆæ¯å†…å®¹",
                    editedText: "ç¼–è¾‘åçš„æ¶ˆæ¯å†…å®¹");
                
                var processingPipeline = GetMessageProcessingPipeline();

                // Act - å¤„ç†åŸå§‹æ¶ˆæ¯
                await processingPipeline.ProcessMessageAsync(originalMessage);
                
                // Act - å¤„ç†ç¼–è¾‘åçš„æ¶ˆæ¯
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(editedMessage);
                var processingTime = StopPerformanceMonitoring("EditedMessageProcessing");

                // Assert
                await AssertMessageExistsAsync(editedMessage.MessageId);
                await AssertMessageProcessedAsync(editedMessage.MessageId);

                // éªŒè¯æ¶ˆæ¯å†…å®¹å·²æ›´æ–°
                var repository = GetMessageRepository();
                var storedMessage = await repository.GetByIdAsync(editedMessage.MessageId);
                Assert.NotNull(storedMessage);
                Assert.Equal("ç¼–è¾‘åçš„æ¶ˆæ¯å†…å®¹", storedMessage.Text);

                // éªŒè¯æ€§èƒ½
                Assert.True(processingTime < 500, $"ç¼–è¾‘æ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 500ms");

                LogTestInfo($"ç¼–è¾‘æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}ms");
            });
        }

        [Fact]
        public async Task ProcessMessageWithSpecialCharacters_ShouldHandleUnicodeCorrectly()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var specialText = "æµ‹è¯•æ¶ˆæ¯åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼šğŸ‰ğŸ˜ŠğŸš€ ä»¥åŠä¸­æ–‡ã€Englishã€æ—¥æœ¬èªã€í•œêµ­ì–´";
                var testMessage = TestDataFactory.CreateTextMessage(text: specialText);
                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(testMessage);
                var processingTime = StopPerformanceMonitoring("SpecialCharactersMessageProcessing");

                // Assert
                await AssertMessageExistsAsync(testMessage.MessageId);
                await AssertMessageProcessedAsync(testMessage.MessageId);

                // éªŒè¯ç‰¹æ®Šå­—ç¬¦è¢«æ­£ç¡®å­˜å‚¨
                var repository = GetMessageRepository();
                var storedMessage = await repository.GetByIdAsync(testMessage.MessageId);
                Assert.NotNull(storedMessage);
                Assert.Equal(specialText, storedMessage.Text);

                // éªŒè¯æ€§èƒ½
                Assert.True(processingTime < 1000, $"ç‰¹æ®Šå­—ç¬¦æ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 1000ms");

                LogTestInfo($"ç‰¹æ®Šå­—ç¬¦æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}ms");
            });
        }

        [Fact]
        public async Task ProcessLargeMessage_ShouldHandleLongContent()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var longText = string.Join(" ", Enumerable.Range(1, 1000).Select(i => $"è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„æµ‹è¯•æ¶ˆæ¯{i}ï¼ŒåŒ…å«å¤§é‡å†…å®¹ç”¨äºæµ‹è¯•ç³»ç»Ÿçš„å¤„ç†èƒ½åŠ›ã€‚"));
                var testMessage = TestDataFactory.CreateTextMessage(text: longText);
                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(testMessage);
                var processingTime = StopPerformanceMonitoring("LargeMessageProcessing");

                // Assert
                await AssertMessageExistsAsync(testMessage.MessageId);
                await AssertMessageProcessedAsync(testMessage.MessageId);

                // éªŒè¯é•¿æ¶ˆæ¯è¢«æ­£ç¡®å­˜å‚¨
                var repository = GetMessageRepository();
                var storedMessage = await repository.GetByIdAsync(testMessage.MessageId);
                Assert.NotNull(storedMessage);
                Assert.Equal(longText, storedMessage.Text);
                Assert.True(storedMessage.Text.Length > 10000, "æ¶ˆæ¯é•¿åº¦åº”è¯¥è¶…è¿‡10000å­—ç¬¦");

                // éªŒè¯æ€§èƒ½
                Assert.True(processingTime < 2000, $"é•¿æ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 2000ms");

                LogTestInfo($"é•¿æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}msï¼Œæ¶ˆæ¯é•¿åº¦: {longText.Length}å­—ç¬¦");
            });
        }

        [Fact]
        public async Task ProcessMessageWithDifferentLanguages_ShouldHandleMultilingualContent()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var multilingualMessages = new[]
                {
                    TestDataFactory.CreateTextMessage(text: "è¿™æ˜¯ä¸­æ–‡æ¶ˆæ¯"),
                    TestDataFactory.CreateTextMessage(text: "This is an English message"),
                    TestDataFactory.CreateTextMessage(text: "ã“ã‚Œã¯æ—¥æœ¬èªã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã™"),
                    TestDataFactory.CreateTextMessage(text: "ì´ê²ƒì€ í•œêµ­ì–´ ë©”ì‹œì§€ì…ë‹ˆë‹¤"),
                    TestDataFactory.CreateTextMessage(text: "Este es un mensaje en espaÃ±ol")
                };

                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                
                var processingTasks = multilingualMessages.Select(async message =>
                {
                    await processingPipeline.ProcessMessageAsync(message);
                });
                
                await Task.WhenAll(processingTasks);
                var totalProcessingTime = StopPerformanceMonitoring("MultilingualMessageProcessing");

                // Assert
                foreach (var message in multilingualMessages)
                {
                    await AssertMessageExistsAsync(message.MessageId);
                    await AssertMessageProcessedAsync(message.MessageId);
                }

                // éªŒè¯æ‰€æœ‰è¯­è¨€çš„æ¶ˆæ¯éƒ½è¢«æ­£ç¡®å¤„ç†
                var repository = GetMessageRepository();
                var allMessages = await repository.GetAllAsync();
                Assert.Equal(multilingualMessages.Length, allMessages.Count());

                // éªŒè¯æ€§èƒ½
                var averageTimePerMessage = totalProcessingTime / multilingualMessages.Length;
                Assert.True(averageTimePerMessage < 800, $"å¹³å‡æ¯æ¡å¤šè¯­è¨€æ¶ˆæ¯å¤„ç†æ—¶é—´ {averageTimePerMessage}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 800ms");

                LogTestInfo($"å¤šè¯­è¨€æ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œæ€»å¤„ç†æ—¶é—´: {totalProcessingTime}msï¼Œå¹³å‡æ¯æ¡: {averageTimePerMessage}ms");
            });
        }

        [Fact]
        public async Task ProcessMessageWithEmptyContent_ShouldHandleGracefully()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var emptyMessage = new Message
                {
                    MessageId = 99999,
                    ChatId = -100123456789,
                    UserId = 123456789,
                    Text = "",
                    Timestamp = DateTime.UtcNow,
                    Processed = false,
                    Vectorized = false
                };

                var processingPipeline = GetMessageProcessingPipeline();

                // Act
                StartPerformanceMonitoring();
                await processingPipeline.ProcessMessageAsync(emptyMessage);
                var processingTime = StopPerformanceMonitoring("EmptyMessageProcessing");

                // Assert
                // ç©ºæ¶ˆæ¯åº”è¯¥è¢«å¤„ç†ï¼Œä½†å¯èƒ½ä¸ä¼šå­˜å‚¨æˆ–ä¼šç‰¹æ®Šå¤„ç†
                // è¿™é‡Œæˆ‘ä»¬éªŒè¯ç³»ç»Ÿä¸ä¼šå´©æºƒ
                Assert.True(processingTime < 500, $"ç©ºæ¶ˆæ¯å¤„ç†æ—¶é—´ {processingTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 500ms");

                LogTestInfo($"ç©ºæ¶ˆæ¯å¤„ç†æµ‹è¯•é€šè¿‡ï¼Œå¤„ç†æ—¶é—´: {processingTime}ms");
            });
        }
    }
}