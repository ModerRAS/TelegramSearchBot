using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using TelegramSearchBot.Domain.Message;
using TelegramSearchBot.Search;
using TelegramSearchBot.Test.Helpers;
using TelegramSearchBot.Test.Integration;
using Xunit;
using Xunit.Abstractions;

namespace TelegramSearchBot.Test.Integration
{
    /// <summary>
    /// æœç´¢åŠŸèƒ½é›†æˆæµ‹è¯•
    /// </summary>
    public class SearchIntegrationTests : IntegrationTestBase
    {
        public SearchIntegrationTests(ITestOutputHelper output) : base(output)
        {
        }

        [Fact]
        public async Task SearchByKeyword_ShouldReturnRelevantResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var keyword = "æœç´¢";

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SearchAsync(keyword, limit: 10);
                var searchTime = StopPerformanceMonitoring("KeywordSearch");

                // Assert
                Assert.NotEmpty(results);
                Assert.True(results.Count <= 10, "æœç´¢ç»“æœæ•°é‡åº”è¯¥ä¸è¶…è¿‡é™åˆ¶");

                // éªŒè¯æœç´¢ç»“æœåŒ…å«å…³é”®è¯
                foreach (var result in results)
                {
                    Assert.Contains(keyword, result.Text, StringComparison.OrdinalIgnoreCase);
                }

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 1000, $"å…³é”®è¯æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 1000ms");

                LogTestInfo($"å…³é”®è¯æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchByMultipleKeywords_ShouldReturnFilteredResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var keywords = new[] { "äººå·¥æ™ºèƒ½", "æœºå™¨å­¦ä¹ " };

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SearchAsync(keywords, limit: 10);
                var searchTime = StopPerformanceMonitoring("MultipleKeywordsSearch");

                // Assert
                Assert.NotEmpty(results);

                // éªŒè¯æœç´¢ç»“æœåŒ…å«è‡³å°‘ä¸€ä¸ªå…³é”®è¯
                foreach (var result in results)
                {
                    var containsKeyword = keywords.Any(keyword => 
                        result.Text.Contains(keyword, StringComparison.OrdinalIgnoreCase));
                    Assert.True(containsKeyword, $"æœç´¢ç»“æœ '{result.Text}' åº”è¯¥åŒ…å«è‡³å°‘ä¸€ä¸ªå…³é”®è¯");
                }

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 1500, $"å¤šå…³é”®è¯æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 1500ms");

                LogTestInfo($"å¤šå…³é”®è¯æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchByDateRange_ShouldReturnTimeFilteredResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var startDate = DateTime.UtcNow.AddHours(-1);
                var endDate = DateTime.UtcNow;

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SearchByDateRangeAsync(startDate, endDate, limit: 10);
                var searchTime = StopPerformanceMonitoring("DateRangeSearch");

                // Assert
                Assert.NotEmpty(results);

                // éªŒè¯æœç´¢ç»“æœåœ¨æŒ‡å®šæ—¶é—´èŒƒå›´å†…
                foreach (var result in results)
                {
                    Assert.True(result.Timestamp >= startDate && result.Timestamp <= endDate,
                        $"æœç´¢ç»“æœæ—¶é—´ {result.Timestamp} åº”è¯¥åœ¨ {startDate} å’Œ {endDate} ä¹‹é—´");
                }

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 1000, $"æ—¶é—´èŒƒå›´æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 1000ms");

                LogTestInfo($"æ—¶é—´èŒƒå›´æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchByUser_ShouldReturnUserSpecificResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var targetUserId = 123456789L;

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SearchByUserAsync(targetUserId, limit: 10);
                var searchTime = StopPerformanceMonitoring("UserSearch");

                // Assert
                Assert.NotEmpty(results);

                // éªŒè¯æœç´¢ç»“æœéƒ½å±äºæŒ‡å®šç”¨æˆ·
                foreach (var result in results)
                {
                    Assert.Equal(targetUserId, result.UserId);
                }

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 800, $"ç”¨æˆ·æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 800ms");

                LogTestInfo($"ç”¨æˆ·æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchByChat_ShouldReturnChatSpecificResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var targetChatId = -100123456789L;

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SearchByChatAsync(targetChatId, limit: 10);
                var searchTime = StopPerformanceMonitoring("ChatSearch");

                // Assert
                Assert.NotEmpty(results);

                // éªŒè¯æœç´¢ç»“æœéƒ½å±äºæŒ‡å®šèŠå¤©
                foreach (var result in results)
                {
                    Assert.Equal(targetChatId, result.ChatId);
                }

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 800, $"èŠå¤©æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 800ms");

                LogTestInfo($"èŠå¤©æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SemanticSearch_ShouldReturnContextuallyRelevantResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var query = "AIæŠ€æœ¯çš„å‘å±•è¶‹åŠ¿";

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SemanticSearchAsync(query, limit: 10);
                var searchTime = StopPerformanceMonitoring("SemanticSearch");

                // Assert
                Assert.NotEmpty(results);

                // è¯­ä¹‰æœç´¢çš„ç»“æœå¯èƒ½ä¸åŒ…å«å®Œå…¨åŒ¹é…çš„å…³é”®è¯
                // ä½†åº”è¯¥åŒ…å«ç›¸å…³æ¦‚å¿µ
                var allText = string.Join(" ", results.Select(r => r.Text));
                Assert.True(allText.Length > 0, "è¯­ä¹‰æœç´¢åº”è¯¥è¿”å›æœ‰å†…å®¹çš„æ–‡æœ¬");

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 2000, $"è¯­ä¹‰æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 2000ms");

                LogTestInfo($"è¯­ä¹‰æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task HybridSearch_ShouldCombineKeywordAndSemanticResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var keyword = "æœºå™¨å­¦ä¹ ";

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.HybridSearchAsync(keyword, limit: 10);
                var searchTime = StopPerformanceMonitoring("HybridSearch");

                // Assert
                Assert.NotEmpty(results);

                // éªŒè¯æ··åˆæœç´¢ç»“æœçš„ç›¸å…³æ€§
                // æ··åˆæœç´¢åº”è¯¥ç»“åˆå…³é”®è¯åŒ¹é…å’Œè¯­ä¹‰ç›¸ä¼¼åº¦
                var keywordMatches = results.Count(r => r.Text.Contains(keyword, StringComparison.OrdinalIgnoreCase));
                var semanticMatches = results.Count - keywordMatches;

                Assert.True(keywordMatches > 0, "æ··åˆæœç´¢åº”è¯¥åŒ…å«å…³é”®è¯åŒ¹é…ç»“æœ");
                Assert.True(results.Count >= keywordMatches, "æ··åˆæœç´¢ç»“æœåº”è¯¥åŒ…å«è¯­ä¹‰åŒ¹é…ç»“æœ");

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 2500, $"æ··åˆæœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 2500ms");

                LogTestInfo($"æ··åˆæœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼ˆå…³é”®è¯åŒ¹é…: {keywordMatches}, è¯­ä¹‰åŒ¹é…: {semanticMatches}ï¼‰ï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchWithPagination_ShouldReturnCorrectPage()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedPerformanceDataAsync(100); // åˆ›å»º100æ¡æµ‹è¯•æ•°æ®
                var searchService = GetService<ISearchService>();
                var keyword = "æµ‹è¯•";

                // Act - è·å–ç¬¬ä¸€é¡µ
                var page1Results = await searchService.SearchAsync(keyword, page: 1, pageSize: 10);
                
                // Act - è·å–ç¬¬äºŒé¡µ
                var page2Results = await searchService.SearchAsync(keyword, page: 2, pageSize: 10);

                // Assert
                Assert.Equal(10, page1Results.Count);
                Assert.True(page2Results.Count <= 10, "ç¬¬äºŒé¡µç»“æœæ•°é‡åº”è¯¥ä¸è¶…è¿‡é¡µé¢å¤§å°");

                // éªŒè¯ä¸¤é¡µç»“æœä¸é‡å¤
                var page1Ids = page1Results.Select(r => r.MessageId).ToHashSet();
                var page2Ids = page2Results.Select(r => r.MessageId).ToHashSet();
                
                Assert.Empty(page1Ids.Intersect(page2Ids), "åˆ†é¡µç»“æœä¸åº”è¯¥æœ‰é‡å¤");

                LogTestInfo($"åˆ†é¡µæœç´¢æµ‹è¯•é€šè¿‡ï¼Œç¬¬ä¸€é¡µ: {page1Results.Count} æ¡ï¼Œç¬¬äºŒé¡µ: {page2Results.Count} æ¡");
            });
        }

        [Fact]
        public async Task SearchWithSorting_ShouldReturnOrderedResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var keyword = "æµ‹è¯•";

                // Act - æŒ‰æ—¶é—´é™åºæ’åº
                var timeDescResults = await searchService.SearchAsync(keyword, sortBy: "time", sortOrder: "desc", limit: 10);
                
                // Act - æŒ‰æ—¶é—´å‡åºæ’åº
                var timeAscResults = await searchService.SearchAsync(keyword, sortBy: "time", sortOrder: "asc", limit: 10);

                // Assert
                Assert.NotEmpty(timeDescResults);
                Assert.NotEmpty(timeAscResults);

                // éªŒè¯é™åºæ’åº
                for (int i = 0; i < timeDescResults.Count - 1; i++)
                {
                    Assert.True(timeDescResults[i].Timestamp >= timeDescResults[i + 1].Timestamp,
                        "é™åºæ’åºç»“æœæ—¶é—´åº”è¯¥é€’å‡");
                }

                // éªŒè¯å‡åºæ’åº
                for (int i = 0; i < timeAscResults.Count - 1; i++)
                {
                    Assert.True(timeAscResults[i].Timestamp <= timeAscResults[i + 1].Timestamp,
                        "å‡åºæ’åºç»“æœæ—¶é—´åº”è¯¥é€’å¢");
                }

                LogTestInfo($"æ’åºæœç´¢æµ‹è¯•é€šè¿‡ï¼Œé™åº: {timeDescResults.Count} æ¡ï¼Œå‡åº: {timeAscResults.Count} æ¡");
            });
        }

        [Fact]
        public async Task SearchWithFilters_ShouldReturnFilteredResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var keyword = "æµ‹è¯•";
                var filters = new Dictionary<string, object>
                {
                    { "processed", true },
                    { "vectorized", true }
                };

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SearchAsync(keyword, filters: filters, limit: 10);
                var searchTime = StopPerformanceMonitoring("FilteredSearch");

                // Assert
                Assert.NotEmpty(results);

                // éªŒè¯æœç´¢ç»“æœç¬¦åˆè¿‡æ»¤æ¡ä»¶
                foreach (var result in results)
                {
                    Assert.True(result.Processed, "æœç´¢ç»“æœåº”è¯¥å·²å¤„ç†");
                    Assert.True(result.Vectorized, "æœç´¢ç»“æœåº”è¯¥å·²å‘é‡åŒ–");
                }

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 1200, $"è¿‡æ»¤æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 1200ms");

                LogTestInfo($"è¿‡æ»¤æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchWithAggregations_ShouldReturnStatistics()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var keyword = "æµ‹è¯•";

                // Act
                StartPerformanceMonitoring();
                var (results, aggregations) = await searchService.SearchWithAggregationsAsync(keyword, 
                    new[] { "userId", "chatId" }, limit: 10);
                var searchTime = StopPerformanceMonitoring("AggregatedSearch");

                // Assert
                Assert.NotEmpty(results);
                Assert.NotNull(aggregations);

                // éªŒè¯èšåˆç»Ÿè®¡
                Assert.True(aggregations.ContainsKey("userId"), "èšåˆç»“æœåº”è¯¥åŒ…å«ç”¨æˆ·ç»Ÿè®¡");
                Assert.True(aggregations.ContainsKey("chatId"), "èšåˆç»“æœåº”è¯¥åŒ…å«èŠå¤©ç»Ÿè®¡");

                // éªŒè¯æ€§èƒ½
                Assert.True(searchTime < 1500, $"èšåˆæœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 1500ms");

                LogTestInfo($"èšåˆæœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œèšåˆå­—æ®µ: {aggregations.Keys.Count}ï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchPerformance_ShouldHandleLargeDataset()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedPerformanceDataAsync(1000); // åˆ›å»º1000æ¡æµ‹è¯•æ•°æ®
                var searchService = GetService<ISearchService>();
                var keyword = "æµ‹è¯•";

                // Act
                StartPerformanceMonitoring();
                var results = await searchService.SearchAsync(keyword, limit: 100);
                var searchTime = StopPerformanceMonitoring("LargeDatasetSearch");

                // Assert
                Assert.NotEmpty(results);
                Assert.True(results.Count <= 100, "æœç´¢ç»“æœæ•°é‡åº”è¯¥ä¸è¶…è¿‡é™åˆ¶");

                // éªŒè¯æ€§èƒ½ - å¤§æ•°æ®é›†æœç´¢åº”è¯¥åœ¨åˆç†æ—¶é—´å†…å®Œæˆ
                Assert.True(searchTime < 3000, $"å¤§æ•°æ®é›†æœç´¢æ—¶é—´ {searchTime}ms è¶…è¿‡é¢„æœŸé˜ˆå€¼ 3000ms");

                LogTestInfo($"å¤§æ•°æ®é›†æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {results.Count} æ¡ç»“æœï¼Œæœç´¢æ—¶é—´: {searchTime}ms");
            });
        }

        [Fact]
        public async Task SearchWithSpecialCharacters_ShouldHandleUnicodeAndEmoji()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                var specialMessages = new[]
                {
                    TestDataFactory.CreateTextMessage(text: "åŒ…å«emojiçš„æ¶ˆæ¯ ğŸ‰ğŸ˜ŠğŸš€"),
                    TestDataFactory.CreateTextMessage(text: "åŒ…å«ç‰¹æ®Šç¬¦å·çš„æ¶ˆæ¯ @#$%^&*()"),
                    TestDataFactory.CreateTextMessage(text: "åŒ…å«ä¸­æ–‡å’ŒEnglishæ··åˆçš„æ¶ˆæ¯"),
                    TestDataFactory.CreateTextMessage(text: "åŒ…å«æ—¥æ–‡æ—¥æœ¬èªå’Œí•œêµ­ì–´çš„æ¶ˆæ¯")
                };

                var messageService = GetMessageService();
                foreach (var message in specialMessages)
                {
                    await messageService.AddMessageAsync(message);
                }

                var searchService = GetService<ISearchService>();

                // Act
                var searchQueries = new[] { "ğŸ‰", "@#$", "English", "æ—¥æœ¬èª" };
                var totalResults = 0;

                foreach (var query in searchQueries)
                {
                    var results = await searchService.SearchAsync(query, limit: 10);
                    totalResults += results.Count;
                }

                // Assert
                Assert.True(totalResults > 0, "ç‰¹æ®Šå­—ç¬¦æœç´¢åº”è¯¥è¿”å›ç»“æœ");

                LogTestInfo($"ç‰¹æ®Šå­—ç¬¦æœç´¢æµ‹è¯•é€šè¿‡ï¼Œæ€»å…±æ‰¾åˆ° {totalResults} æ¡ç»“æœ");
            });
        }

        [Fact]
        public async Task SearchWithEmptyQuery_ShouldReturnAllResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();

                // Act
                var results = await searchService.SearchAsync("", limit: 10);

                // Assert
                Assert.NotEmpty(results);
                Assert.True(results.Count <= 10, "ç©ºæŸ¥è¯¢ç»“æœæ•°é‡åº”è¯¥ä¸è¶…è¿‡é™åˆ¶");

                LogTestInfo($"ç©ºæŸ¥è¯¢æœç´¢æµ‹è¯•é€šè¿‡ï¼Œè¿”å› {results.Count} æ¡ç»“æœ");
            });
        }

        [Fact]
        public async Task SearchNonExistentContent_ShouldReturnEmptyResults()
        {
            await ExecuteTestAsync(async () =>
            {
                // Arrange
                await SeedBasicDataAsync();
                var searchService = GetService<ISearchService>();
                var nonExistentKeyword = "è¿™ä¸ªå…³é”®è¯è‚¯å®šä¸å­˜åœ¨äºä»»ä½•æ¶ˆæ¯ä¸­";

                // Act
                var results = await searchService.SearchAsync(nonExistentKeyword, limit: 10);

                // Assert
                Assert.Empty(results);

                LogTestInfo($"ä¸å­˜åœ¨å†…å®¹æœç´¢æµ‹è¯•é€šè¿‡ï¼Œè¿”å› {results.Count} æ¡ç»“æœ");
            });
        }
    }
}